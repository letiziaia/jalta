import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import * as React from 'react';
import { memo, useRef, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { v4 as uuid } from 'uuid';
import SeriesContext from '../SeriesContext';
import { getNonEventHandlerProps, getEventsConfig } from '../../utils/events';
import getModifiedProps from '../../utils/getModifiedProps';
import { logSeriesErrorMessage } from '../../utils/warnings';
import usePrevious from '../UsePrevious';
import useHighcharts from '../UseHighcharts';
import useChart from '../UseChart';
import useAxis from '../UseAxis';
import useColorAxis from '../UseColorAxis';
import createProvidedSeries from './createProvidedSeries';
var EMPTY_ARRAY = [];
var Series = /*#__PURE__*/memo(function (_ref) {
  var _ref$id = _ref.id,
      id = _ref$id === void 0 ? uuid : _ref$id,
      _ref$data = _ref.data,
      data = _ref$data === void 0 ? EMPTY_ARRAY : _ref$data,
      _ref$isDataEqual = _ref.isDataEqual,
      isDataEqual = _ref$isDataEqual === void 0 ? Object.is : _ref$isDataEqual,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'line' : _ref$type,
      _ref$visible = _ref.visible,
      visible = _ref$visible === void 0 ? true : _ref$visible,
      _ref$children = _ref.children,
      children = _ref$children === void 0 ? null : _ref$children,
      axisId = _ref.axisId,
      _ref$requiresAxis = _ref.requiresAxis,
      requiresAxis = _ref$requiresAxis === void 0 ? true : _ref$requiresAxis,
      jsxOptions = _ref.jsxOptions,
      restProps = _objectWithoutProperties(_ref, ["id", "data", "isDataEqual", "type", "visible", "children", "axisId", "requiresAxis", "jsxOptions"]);

  var seriesProps = _objectSpread({
    id: id,
    data: data,
    type: type,
    visible: visible
  }, restProps);
  /*
    if (defaultTo(restProps.requiresAxis, true)) {
      const axis = getAxis();
      if(!axis) throw new Error(`Series type="${restProps.type}" should be wrapped inside Axis`);
    }
  */


  var Highcharts = useHighcharts();

  var _useChart = useChart(),
      addSeries = _useChart.addSeries,
      needsRedraw = _useChart.needsRedraw;

  if (process.env.NODE_ENV === 'development') {
    var seriesTypes = Object.keys(Highcharts.seriesTypes);
    if (seriesTypes.indexOf(type) === -1) logSeriesErrorMessage(type);
  }

  var seriesRef = useRef(null);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      setHasSeries = _useState2[1];

  var providerValueRef = useRef(null);
  var axis = useAxis(axisId);
  var colorAxis = useColorAxis();
  useEffect(function () {
    if (requiresAxis && !axis) return;
    var opts = getSeriesConfig(seriesProps, axis, colorAxis, requiresAxis);
    var series = addSeries(opts, false);
    seriesRef.current = series;
    providerValueRef.current = createProvidedSeries(seriesRef.current);
    setHasSeries(true);
    needsRedraw();
    return function () {
      if (series && series.remove) {
        try {
          series.remove.bind(series)(false);
          seriesRef.current = null;
        } catch (_unused) {// Series may have already been removed, i.e. when Axis unmounted
        }

        needsRedraw();
      }
    };
  }, [axis]);
  var prevProps = usePrevious(seriesProps);
  useEffect(function () {
    if (!prevProps || !seriesRef.current) return;
    var series = seriesRef.current;

    var visible = seriesProps.visible,
        data = seriesProps.data,
        rest = _objectWithoutProperties(seriesProps, ["visible", "data"]);

    var doRedraw = false; // Using setData is more performant than update

    if (isDataEqual(data, prevProps.data) === false) {
      var animation = jsxOptions && jsxOptions.animation;
      var updatePoints = jsxOptions && jsxOptions.updatePoints;
      series.setData(data, false, animation, updatePoints);
      doRedraw = true;
    }

    if (visible !== prevProps.visible) {
      series.setVisible(visible, false);
      doRedraw = true;
    }

    var modifiedProps = getModifiedProps(prevProps, rest);

    if (modifiedProps !== false) {
      series.update(modifiedProps, false);
      doRedraw = true;
    }

    if (doRedraw) {
      needsRedraw();
    }
  });
  if (!seriesRef.current) return null;
  return /*#__PURE__*/React.createElement(SeriesContext.Provider, {
    value: providerValueRef.current
  }, children);
});
Series.displayName = 'Series';

var getSeriesConfig = function getSeriesConfig(props, axis, colorAxis, requiresAxis) {
  var id = props.id,
      data = props.data,
      rest = _objectWithoutProperties(props, ["id", "data"]);

  var seriesId = typeof id === 'function' ? id() : id;
  var nonEventProps = getNonEventHandlerProps(rest);
  var events = getEventsConfig(rest);

  var config = _objectSpread({
    id: seriesId,
    data: data,
    events: events
  }, nonEventProps);

  if (colorAxis) {
    config.colorAxis = colorAxis.id;
  }

  if (requiresAxis) {
    config[axis.type] = axis.id;
  }

  return config;
};

export default Series;